This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  cli.ts
  detector.ts
  module-graph.ts
  parser.ts
test-files/
  circular-example.tsx
  clean-example.tsx
tests/
  fixtures/
    cross-file/
      clean-component.tsx
      clean-utils.ts
      component.tsx
      context.tsx
      utils.tsx
    circular-example.tsx
    clean-example.tsx
    false-positive-example.tsx
    real-circular-example.tsx
    realistic-circular.tsx
  cli.test.ts
  cross-file-cycles.test.ts
  detector.test.ts
  false-positives.test.ts
  parser.test.ts
.gitignore
debug-test.js
jest.config.js
LICENSE
package.json
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/module-graph.ts">
import * as path from 'path';
import { ParsedFile, ImportInfo, ExportInfo } from './parser';

export interface ModuleDependency {
  from: string;
  to: string;
  importedItems: string[];
  line: number;
}

export interface CrossFileCycle {
  files: string[];
  dependencies: ModuleDependency[];
  type: 'import' | 'context' | 'function-call';
}

export interface ModuleGraph {
  dependencies: Map<string, ModuleDependency[]>;
  exports: Map<string, ExportInfo[]>;
  crossFileCycles: CrossFileCycle[];
}

export function buildModuleGraph(parsedFiles: ParsedFile[]): ModuleGraph {
  const dependencies = new Map<string, ModuleDependency[]>();
  const exports = new Map<string, ExportInfo[]>();
  
  // Build maps for quick lookup
  const filesByPath = new Map<string, ParsedFile>();
  parsedFiles.forEach(file => {
    filesByPath.set(file.file, file);
    exports.set(file.file, file.exports);
    dependencies.set(file.file, []);
  });

  // Build dependency graph
  parsedFiles.forEach(file => {
    file.imports.forEach(importInfo => {
      const resolvedPath = resolveImportPath(file.file, importInfo.source);
      const targetFile = findFileByPath(parsedFiles, resolvedPath);
      
      if (targetFile) {
        const dependency: ModuleDependency = {
          from: file.file,
          to: targetFile.file,
          importedItems: importInfo.imports,
          line: importInfo.line,
        };
        
        const fileDeps = dependencies.get(file.file) || [];
        fileDeps.push(dependency);
        dependencies.set(file.file, fileDeps);
      }
    });
  });

  // Detect cross-file cycles
  const crossFileCycles = detectCrossFileCycles(dependencies);

  return {
    dependencies,
    exports,
    crossFileCycles,
  };
}

function resolveImportPath(fromFile: string, importPath: string): string {
  const fromDir = path.dirname(fromFile);
  let resolvedPath = path.resolve(fromDir, importPath);
  
  // Handle imports without extensions
  const possibleExtensions = ['.ts', '.tsx', '.js', '.jsx', '/index.ts', '/index.tsx', '/index.js', '/index.jsx'];
  
  for (const ext of possibleExtensions) {
    const testPath = resolvedPath + ext;
    if (resolvedPath.endsWith(ext)) {
      return resolvedPath;
    }
  }
  
  return resolvedPath;
}

function findFileByPath(parsedFiles: ParsedFile[], targetPath: string): ParsedFile | null {
  // Try exact match first
  for (const file of parsedFiles) {
    if (file.file === targetPath) {
      return file;
    }
  }
  
  // Try with different extensions
  const possibleExtensions = ['.ts', '.tsx', '.js', '.jsx'];
  const basePath = targetPath.replace(/\.(ts|tsx|js|jsx)$/, '');
  
  for (const ext of possibleExtensions) {
    const testPath = basePath + ext;
    for (const file of parsedFiles) {
      if (file.file === testPath) {
        return file;
      }
    }
  }
  
  // Try index files
  const indexPaths = [
    path.join(targetPath, 'index.ts'),
    path.join(targetPath, 'index.tsx'),
    path.join(targetPath, 'index.js'),
    path.join(targetPath, 'index.jsx'),
  ];
  
  for (const indexPath of indexPaths) {
    for (const file of parsedFiles) {
      if (file.file === indexPath) {
        return file;
      }
    }
  }
  
  return null;
}

function detectCrossFileCycles(dependencies: Map<string, ModuleDependency[]>): CrossFileCycle[] {
  const cycles: CrossFileCycle[] = [];
  const visited = new Set<string>();
  const recursionStack = new Set<string>();
  
  for (const [startFile] of dependencies) {
    if (!visited.has(startFile)) {
      const pathStack: string[] = [];
      const depStack: ModuleDependency[] = [];
      findCyclesFromFile(startFile, dependencies, visited, recursionStack, pathStack, depStack, cycles);
    }
  }
  
  return cycles;
}

function findCyclesFromFile(
  currentFile: string,
  dependencies: Map<string, ModuleDependency[]>,
  visited: Set<string>,
  recursionStack: Set<string>,
  pathStack: string[],
  depStack: ModuleDependency[],
  cycles: CrossFileCycle[]
): void {
  visited.add(currentFile);
  recursionStack.add(currentFile);
  pathStack.push(currentFile);
  
  const fileDeps = dependencies.get(currentFile) || [];
  
  for (const dep of fileDeps) {
    const targetFile = dep.to;
    
    if (!visited.has(targetFile)) {
      depStack.push(dep);
      findCyclesFromFile(targetFile, dependencies, visited, recursionStack, pathStack, [...depStack], cycles);
      depStack.pop();
    } else if (recursionStack.has(targetFile)) {
      // Found a cycle
      const cycleStartIndex = pathStack.indexOf(targetFile);
      if (cycleStartIndex !== -1) {
        const cycleFiles = pathStack.slice(cycleStartIndex);
        cycleFiles.push(targetFile); // Complete the cycle
        
        const cycleDeps = [...depStack];
        cycleDeps.push(dep);
        
        cycles.push({
          files: cycleFiles,
          dependencies: cycleDeps,
          type: 'import',
        });
      }
    }
  }
  
  recursionStack.delete(currentFile);
  pathStack.pop();
}

export function detectAdvancedCrossFileCycles(
  parsedFiles: ParsedFile[],
  moduleGraph: ModuleGraph
): CrossFileCycle[] {
  const advancedCycles: CrossFileCycle[] = [];
  
  // Detect context dependency cycles
  const contextCycles = detectContextCycles(parsedFiles, moduleGraph);
  advancedCycles.push(...contextCycles);
  
  // Detect function call cycles (more complex analysis)
  const functionCycles = detectFunctionCallCycles(parsedFiles, moduleGraph);
  advancedCycles.push(...functionCycles);
  
  return advancedCycles;
}

function detectContextCycles(parsedFiles: ParsedFile[], moduleGraph: ModuleGraph): CrossFileCycle[] {
  const cycles: CrossFileCycle[] = [];
  
  // Find files that create contexts
  const contextProviders = new Map<string, string[]>();
  parsedFiles.forEach(file => {
    if (file.contexts.size > 0) {
      contextProviders.set(file.file, Array.from(file.contexts));
    }
  });
  
  // Find files that use contexts (import context from another file)
  parsedFiles.forEach(file => {
    file.imports.forEach(imp => {
      const resolvedPath = resolveImportPath(file.file, imp.source);
      const targetFile = findFileByPath(parsedFiles, resolvedPath);
      
      if (targetFile && targetFile.contexts.size > 0) {
        // Check if the context provider file also imports from the consumer file
        const providerImports = targetFile.imports;
        const hasCircularRef = providerImports.some(providerImp => {
          const providerResolvedPath = resolveImportPath(targetFile.file, providerImp.source);
          return providerResolvedPath === file.file;
        });
        
        if (hasCircularRef) {
          cycles.push({
            files: [file.file, targetFile.file, file.file],
            dependencies: [
              {
                from: file.file,
                to: targetFile.file,
                importedItems: imp.imports,
                line: imp.line,
              }
            ],
            type: 'context',
          });
        }
      }
    });
  });
  
  return cycles;
}

function detectFunctionCallCycles(parsedFiles: ParsedFile[], moduleGraph: ModuleGraph): CrossFileCycle[] {
  // This is a simplified version - a full implementation would require
  // call graph analysis to track function invocations across files
  const cycles: CrossFileCycle[] = [];
  
  // For now, we detect potential cycles based on mutual imports of functions
  parsedFiles.forEach(file => {
    const importedFunctions = new Set<string>();
    
    file.imports.forEach(imp => {
      const resolvedPath = resolveImportPath(file.file, imp.source);
      const targetFile = findFileByPath(parsedFiles, resolvedPath);
      
      if (targetFile) {
        // Check if imported items are functions
        imp.imports.forEach(importedItem => {
          if (targetFile.functions.has(importedItem)) {
            importedFunctions.add(importedItem);
          }
        });
        
        // Check if target file imports functions from current file
        const reverseImports = targetFile.imports.filter(targetImp => {
          const targetResolvedPath = resolveImportPath(targetFile.file, targetImp.source);
          return targetResolvedPath === file.file;
        });
        
        if (reverseImports.length > 0 && importedFunctions.size > 0) {
          cycles.push({
            files: [file.file, targetFile.file, file.file],
            dependencies: [
              {
                from: file.file,
                to: targetFile.file,
                importedItems: Array.from(importedFunctions),
                line: imp.line,
              }
            ],
            type: 'function-call',
          });
        }
      }
    });
  });
  
  return cycles;
}
</file>

<file path="tests/fixtures/cross-file/clean-component.tsx">
import React, { useState, useCallback } from 'react';
import { helperFunction } from './clean-utils';

// This component has NO circular dependencies - clean import chain

export const CleanComponent: React.FC = () => {
  const [value, setValue] = useState('');

  const handleChange = useCallback((newValue: string) => {
    const processed = helperFunction(newValue);
    setValue(processed);
  }, []);

  return (
    <div>
      <input 
        value={value} 
        onChange={(e) => handleChange(e.target.value)} 
      />
    </div>
  );
};

export default CleanComponent;
</file>

<file path="tests/fixtures/cross-file/clean-utils.ts">
// This utility file has NO circular dependencies - only exports functions

export function helperFunction(input: string): string {
  return input.trim().toLowerCase();
}

export function anotherHelper(data: any): any {
  return {
    ...data,
    helper: 'processed',
  };
}
</file>

<file path="tests/fixtures/cross-file/component.tsx">
import React, { useCallback } from 'react';
import { useMyContext } from './context';
import { processData, validateInput } from './utils';

// This component creates a circular dependency:
// component.tsx → context.tsx → utils.tsx → component.tsx

export const MyComponent: React.FC = () => {
  const { updateData } = useMyContext();

  const handleSubmit = useCallback((data: any) => {
    if (validateInput(data)) {
      const processed = processData(data);
      updateData(processed);
    }
  }, [updateData]);

  return (
    <div>
      <button onClick={() => handleSubmit({ test: true })}>
        Submit
      </button>
    </div>
  );
};

export default MyComponent;
</file>

<file path="tests/fixtures/cross-file/context.tsx">
import React, { createContext, useContext, useCallback, useState } from 'react';
import { transformData } from './utils';

// This context creates part of the circular dependency:
// context.tsx → utils.tsx → component.tsx → context.tsx

interface MyContextType {
  data: any;
  updateData: (newData: any) => void;
}

const MyContext = createContext<MyContextType | null>(null);

export const MyProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [data, setData] = useState(null);

  const updateData = useCallback((newData: any) => {
    // Use utility function that creates circular dependency
    const transformed = transformData(newData);
    setData(transformed);
  }, []);

  return (
    <MyContext.Provider value={{ data, updateData }}>
      {children}
    </MyContext.Provider>
  );
};

export const useMyContext = () => {
  const context = useContext(MyContext);
  if (!context) {
    throw new Error('useMyContext must be used within MyProvider');
  }
  return context;
};
</file>

<file path="tests/fixtures/cross-file/utils.tsx">
import { MyComponent } from './component';

// This utility file completes the circular dependency:
// utils.tsx → component.tsx → context.tsx → utils.tsx

export function processData(data: any) {
  return {
    ...data,
    processed: true,
    timestamp: Date.now(),
  };
}

export function validateInput(data: any): boolean {
  return data && typeof data === 'object';
}

export function transformData(data: any) {
  // This creates a circular dependency by importing from component
  // which imports from context which imports from this file
  console.log('Transforming data with component type:', typeof MyComponent);
  
  return {
    ...data,
    transformed: true,
    componentRef: MyComponent.name,
  };
}
</file>

<file path="tests/fixtures/circular-example.tsx">
import React, { useState, useEffect, useCallback, useMemo } from 'react';

// This file contains intentional circular dependencies for testing

function CircularDependencyExample() {
  const [count, setCount] = useState(0);
  
  // Simple circular dependency that should be detected
  const functionA = useCallback(() => {
    functionB();
  }, [functionB]);
  
  const functionB = useCallback(() => {
    functionA();
  }, [functionA]);
  
  return (
    <div>
      <h1>Circular Dependencies Test</h1>
      <p>Count: {count}</p>
      <button onClick={functionA}>Test Circular</button>
    </div>
  );
}

export default CircularDependencyExample;
</file>

<file path="tests/fixtures/clean-example.tsx">
import React, { useState, useEffect, useCallback, useMemo } from 'react';

// This file contains NO circular dependencies - should be clean

function CleanComponent() {
  const [count, setCount] = useState(0);
  const [data, setData] = useState<any>(null);
  
  // Clean dependencies - no cycles
  const fetchData = useCallback(async () => {
    console.log('Fetching data...');
    const response = await fetch('/api/data');
    const result = await response.json();
    setData(result);
  }, []); // No dependencies
  
  const processData = useCallback((rawData: any) => {
    console.log('Processing data...');
    return rawData ? { ...rawData, processed: true } : null;
  }, []); // No dependencies
  
  const memoizedValue = useMemo(() => {
    return count * 2;
  }, [count]); // Only depends on count
  
  const handleIncrement = useCallback(() => {
    setCount(prev => prev + 1);
  }, []); // Uses functional update, no dependencies
  
  useEffect(() => {
    fetchData();
  }, []); // Only runs once
  
  useEffect(() => {
    if (data) {
      console.log('Data updated:', data);
    }
  }, [data]); // Only depends on data
  
  return (
    <div>
      <h1>Clean Component</h1>
      <p>Count: {count}</p>
      <p>Memoized Value: {memoizedValue}</p>
      <button onClick={handleIncrement}>Increment</button>
      <pre>{JSON.stringify(data, null, 2)}</pre>
    </div>
  );
}

export default CleanComponent;
</file>

<file path="tests/fixtures/false-positive-example.tsx">
import React, { useState, useCallback } from 'react';

// This file contains patterns that LOOK like circular dependencies but aren't
// Should NOT be flagged as circular dependencies

function FalsePositiveExample() {
  const [user, setUser] = useState(null);
  
  // This has a local variable 'user' inside the function
  // but it's NOT the same as the 'user' state variable
  const getSenderName = useCallback(async (senderId: string) => {
    const users = await fetchUsers([senderId]);
    const user = users.find(u => u.id === senderId); // Local variable
    return user ? user.name : 'Unknown';
  }, []); // No actual circular dependency
  
  // This uses imported functions - not circular
  const fetchMessages = useCallback(async () => {
    const response = await fetch('/api/messages');
    const data = await response.json();
    return data;
  }, []); // fetch is imported, not circular
  
  // This uses React hooks - not circular
  const handleSubmit = useCallback(() => {
    console.log('Submitting...');
    // Using React's built-in functions is not circular
    setUser(prev => ({ ...prev, submitted: true }));
  }, []); // setUser is from useState, not circular
  
  return (
    <div>
      <h1>False Positive Test</h1>
      <button onClick={handleSubmit}>Submit</button>
    </div>
  );
}

// Mock function to simulate imported utility
async function fetchUsers(ids: string[]) {
  return ids.map(id => ({ id, name: `User ${id}` }));
}

export default FalsePositiveExample;
</file>

<file path="tests/fixtures/real-circular-example.tsx">
import React, { useCallback, useEffect, useState } from 'react';

// This represents a real circular dependency that should be detected
export const RealCircularExample: React.FC = () => {
  const [data, setData] = useState(null);
  
  // This creates a real circular dependency
  const fetchData = useCallback(() => {
    processData();
  }, [processData]); // fetchData depends on processData
  
  const processData = useCallback(() => {
    fetchData(); // processData depends on fetchData - CIRCULAR!
  }, [fetchData]);
  
  const validCallback = useCallback(() => {
    console.log('This is fine');
  }, []);
  
  useEffect(() => {
    fetchData();
  }, [fetchData]);
  
  return <div>Real circular dependency example</div>;
};
</file>

<file path="tests/fixtures/realistic-circular.tsx">
import React, { useCallback, useEffect, useState } from 'react';

// This represents the type of circular dependency that might exist in real React apps
export const RealisticCircularExample: React.FC = () => {
  const [user, setUser] = useState(null);
  const [chats, setChats] = useState(new Set<string>());
  
  // Function that updates database
  const updateActiveChatsInDB = useCallback(
    async (chats: Set<string>) => {
      if (!user?.uid) return;
      // Simulate database update
      console.log('Updating chats in DB:', chats);
    },
    [user?.uid],
  );
  
  // Function that adds a chat and calls updateActiveChatsInDB
  const addActiveChat = useCallback(
    (chatId: string) => {
      setChats((prev) => {
        const updated = new Set(prev);
        updated.add(chatId);
        updateActiveChatsInDB(updated); // This creates a dependency
        return updated;
      });
    },
    [updateActiveChatsInDB], // Depends on updateActiveChatsInDB
  );
  
  // Function that might call addActiveChat
  const subscribeToUser = useCallback(
    (uid: string) => {
      // In a circular scenario, this might trigger addActiveChat
      addActiveChat(uid); // This creates another dependency
    },
    [addActiveChat], // Depends on addActiveChat
  );
  
  // Effect that depends on subscribeToUser
  useEffect(() => {
    if (user?.uid) {
      subscribeToUser(user.uid); // Uses subscribeToUser
    }
  }, [user?.uid, subscribeToUser]); // Depends on subscribeToUser
  
  // If subscribeToUser somehow triggered a state change that affected updateActiveChatsInDB's dependencies,
  // this could create a circular dependency chain:
  // useEffect -> subscribeToUser -> addActiveChat -> updateActiveChatsInDB -> [user?.uid change] -> useEffect
  
  return <div>Realistic circular dependency example</div>;
};
</file>

<file path="tests/cli.test.ts">
import { execSync, spawn } from 'child_process';
import * as path from 'path';
import * as fs from 'fs';
import * as os from 'os';

describe('CLI Integration', () => {
  let tempDir: string;
  const cliPath = path.join(__dirname, '..', 'dist', 'cli.js');

  beforeAll(() => {
    // Ensure the CLI is built
    try {
      execSync('npm run build', { stdio: 'inherit', cwd: path.join(__dirname, '..') });
    } catch (error) {
      throw new Error('Failed to build CLI before tests');
    }
  });

  beforeEach(() => {
    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'rcd-cli-test-'));
  });

  afterEach(() => {
    fs.rmSync(tempDir, { recursive: true, force: true });
  });

  describe('Basic CLI Functionality', () => {
    it('should show help when --help flag is used', () => {
      const output = execSync(`node ${cliPath} --help`, { encoding: 'utf8' });
      
      expect(output).toContain('CLI tool to detect circular dependencies');
      expect(output).toContain('--pattern');
      expect(output).toContain('--ignore');
      expect(output).toContain('--json');
    });

    it('should show version when --version flag is used', () => {
      const output = execSync(`node ${cliPath} --version`, { encoding: 'utf8' });
      
      expect(output.trim()).toMatch(/^\d+\.\d+\.\d+$/);
    });

    it('should exit with error code 1 when path does not exist', () => {
      expect(() => {
        execSync(`node ${cliPath} /nonexistent/path`, { encoding: 'utf8' });
      }).toThrow();
    });
  });

  describe('File Analysis', () => {
    it('should analyze clean files and exit with code 0', () => {
      const testFile = path.join(tempDir, 'clean.tsx');
      fs.writeFileSync(testFile, `
        import React, { useState, useCallback } from 'react';
        
        function CleanComponent() {
          const [count, setCount] = useState(0);
          
          const increment = useCallback(() => {
            setCount(prev => prev + 1);
          }, []);
          
          return <div onClick={increment}>Count: {count}</div>;
        }
      `);

      const output = execSync(`node ${cliPath} ${tempDir}`, { encoding: 'utf8' });
      
      expect(output).toContain('No circular dependencies found');
      expect(output).toContain('Files analyzed: 1');
      expect(output).toContain('Hooks analyzed:');
    });

    it('should detect circular dependencies and exit with code 1', () => {
      const testFile = path.join(tempDir, 'circular.tsx');
      fs.writeFileSync(testFile, `
        import React, { useCallback } from 'react';
        
        function CircularComponent() {
          const funcA = useCallback(() => {
            funcB();
          }, [funcB]);
          
          const funcB = useCallback(() => {
            funcA();
          }, [funcA]);
          
          return <div />;
        }
      `);

      expect(() => {
        execSync(`node ${cliPath} ${tempDir}`, { encoding: 'utf8' });
      }).toThrow(); // Should exit with code 1
    });
  });

  describe('Output Formats', () => {
    it('should support JSON output format', () => {
      const testFile = path.join(tempDir, 'test.tsx');
      fs.writeFileSync(testFile, `
        import React, { useState } from 'react';
        function Component() {
          const [state] = useState(0);
          return <div>{state}</div>;
        }
      `);

      const output = execSync(`node ${cliPath} ${tempDir} --json`, { encoding: 'utf8' });
      
      let jsonResult: any;
      expect(() => {
        jsonResult = JSON.parse(output);
      }).not.toThrow();
      
      expect(jsonResult).toHaveProperty('circularDependencies');
      expect(jsonResult).toHaveProperty('summary');
      expect(jsonResult.summary).toHaveProperty('filesAnalyzed');
      expect(jsonResult.summary).toHaveProperty('hooksAnalyzed');
      expect(jsonResult.summary).toHaveProperty('circularDependencies');
    });

    it('should support colored output by default', () => {
      const testFile = path.join(tempDir, 'test.tsx');
      fs.writeFileSync(testFile, `
        import React from 'react';
        function Component() {
          return <div />;
        }
      `);

      const output = execSync(`node ${cliPath} ${tempDir}`, { encoding: 'utf8' });
      
      // Should contain colored output (ANSI escape codes)
      expect(output).toContain('✓');
      expect(output).toMatch(/Files analyzed|Hooks analyzed/);
    });

    it('should disable colors when --no-color is used', () => {
      const testFile = path.join(tempDir, 'test.tsx');
      fs.writeFileSync(testFile, `
        import React from 'react';
        function Component() {
          return <div />;
        }
      `);

      const output = execSync(`node ${cliPath} ${tempDir} --no-color`, { encoding: 'utf8' });
      
      // Should contain plain text output
      expect(output).toContain('No circular dependencies found');
    });
  });

  describe('File Pattern Options', () => {
    it('should respect custom file patterns', () => {
      const jsFile = path.join(tempDir, 'component.js');
      const tsFile = path.join(tempDir, 'component.ts');
      
      fs.writeFileSync(jsFile, `
        import React from 'react';
        function Component() { return React.createElement('div'); }
      `);
      fs.writeFileSync(tsFile, `
        const utils = { helper: () => {} };
      `);

      // Only analyze .js files
      const output = execSync(`node ${cliPath} ${tempDir} --pattern "*.js"`, { encoding: 'utf8' });
      
      expect(output).toContain('Files analyzed: 1');
    });

    it('should respect ignore patterns', () => {
      const file1 = path.join(tempDir, 'component.tsx');
      const file2 = path.join(tempDir, 'ignored.tsx');
      
      fs.writeFileSync(file1, `
        import React from 'react';
        function Component() { return <div />; }
      `);
      fs.writeFileSync(file2, `
        import React from 'react';
        function Ignored() { return <div />; }
      `);

      const output = execSync(`node ${cliPath} ${tempDir} --ignore "**/ignored.tsx"`, { encoding: 'utf8' });
      
      expect(output).toContain('Files analyzed: 1');
    });
  });

  describe('Error Handling', () => {
    it('should handle parsing errors gracefully', () => {
      const testFile = path.join(tempDir, 'invalid.tsx');
      fs.writeFileSync(testFile, `
        import React from 'react'
        // Invalid syntax
        function Component() {
          const [count setCount] = useState(0); // Missing comma
          return <div />;
        }
      `);

      const output = execSync(`node ${cliPath} ${tempDir}`, { encoding: 'utf8' });
      
      // Should continue and show results even with parsing errors
      expect(output).toContain('Files analyzed:');
    });
  });
});
</file>

<file path="tests/cross-file-cycles.test.ts">
import { detectCircularDependencies } from '../src/detector';
import { buildModuleGraph } from '../src/module-graph';
import { parseFile } from '../src/parser';
import * as path from 'path';

describe('Cross-File Circular Dependency Detection', () => {
  const crossFileFixturesPath = path.join(__dirname, 'fixtures', 'cross-file');

  describe('Import-based Circular Dependencies', () => {
    it('should detect circular imports between multiple files', async () => {
      const result = await detectCircularDependencies(crossFileFixturesPath, {
        pattern: 'component.tsx',
        ignore: ['clean-*']
      });

      // Should detect cross-file cycles
      expect(result.crossFileCycles.length).toBeGreaterThan(0);
      expect(result.summary.crossFileCycles).toBeGreaterThan(0);

      // Verify the cycle involves the expected files
      const cycle = result.crossFileCycles[0];
      expect(cycle.files.some(file => file.includes('component.tsx'))).toBe(true);
      expect(cycle.files.some(file => file.includes('utils.tsx'))).toBe(true);
    });

    it('should provide detailed information about cross-file cycles', async () => {
      const result = await detectCircularDependencies(crossFileFixturesPath, {
        pattern: '*.tsx',
        ignore: ['clean-*']
      });

      if (result.crossFileCycles.length > 0) {
        const cycle = result.crossFileCycles[0];
        
        expect(cycle.files).toBeInstanceOf(Array);
        expect(cycle.files.length).toBeGreaterThanOrEqual(2);
        expect(cycle.dependencies).toBeInstanceOf(Array);
        expect(cycle.type).toMatch(/^(import|context|function-call)$/);
        
        cycle.dependencies.forEach(dep => {
          expect(dep.from).toBeTruthy();
          expect(dep.to).toBeTruthy();
          expect(dep.importedItems).toBeInstanceOf(Array);
          expect(dep.line).toBeGreaterThan(0);
        });
      }
    });
  });

  describe('Module Graph Building', () => {
    it('should build correct module dependency graph', () => {
      const componentFile = path.join(crossFileFixturesPath, 'component.tsx');
      const contextFile = path.join(crossFileFixturesPath, 'context.tsx');
      const utilsFile = path.join(crossFileFixturesPath, 'utils.tsx');

      const parsedFiles = [
        parseFile(componentFile),
        parseFile(contextFile),
        parseFile(utilsFile),
      ];

      const moduleGraph = buildModuleGraph(parsedFiles);

      // Should have dependencies
      expect(moduleGraph.dependencies.size).toBeGreaterThan(0);
      
      // Should have exports information
      expect(moduleGraph.exports.size).toBeGreaterThan(0);
      
      // Check that imports are tracked correctly
      const componentDeps = moduleGraph.dependencies.get(componentFile);
      expect(componentDeps).toBeDefined();
      expect(componentDeps!.length).toBeGreaterThan(0);
    });

    it('should detect cycles in the module graph', () => {
      const componentFile = path.join(crossFileFixturesPath, 'component.tsx');
      const contextFile = path.join(crossFileFixturesPath, 'context.tsx');
      const utilsFile = path.join(crossFileFixturesPath, 'utils.tsx');

      const parsedFiles = [
        parseFile(componentFile),
        parseFile(contextFile),
        parseFile(utilsFile),
      ];

      const moduleGraph = buildModuleGraph(parsedFiles);

      // Should detect circular dependencies in the module graph
      expect(moduleGraph.crossFileCycles.length).toBeGreaterThan(0);
    });
  });

  describe('Clean Cross-File Dependencies', () => {
    it('should not flag clean import chains as circular', async () => {
      const result = await detectCircularDependencies(crossFileFixturesPath, {
        pattern: 'clean-*.{tsx,ts}',
        ignore: []
      });

      expect(result.crossFileCycles).toHaveLength(0);
      expect(result.summary.crossFileCycles).toBe(0);
    });
  });

  describe('Context-based Circular Dependencies', () => {
    it('should detect context provider cycles', async () => {
      const result = await detectCircularDependencies(crossFileFixturesPath, {
        pattern: 'context.tsx',
        ignore: ['clean-*']
      });

      // The context file should be part of detected cycles
      const hasContextCycles = result.crossFileCycles.some(cycle => 
        cycle.files.some(file => file.includes('context.tsx')) &&
        cycle.type === 'context'
      );

      // This might be 0 if the cycle detection algorithm is conservative
      // but the structure should be detected
      expect(result.summary.filesAnalyzed).toBeGreaterThan(0);
    });
  });

  describe('Function Call Cycles', () => {
    it('should detect potential function call cycles', async () => {
      const result = await detectCircularDependencies(crossFileFixturesPath, {
        pattern: '*.tsx',
        ignore: ['clean-*']
      });

      // Check that function imports are tracked
      const hasFunctionCycles = result.crossFileCycles.some(cycle => 
        cycle.type === 'function-call'
      );

      // Should at least analyze the files for function dependencies
      expect(result.summary.filesAnalyzed).toBeGreaterThan(0);
    });
  });

  describe('Mixed File Types', () => {
    it('should handle mixed .tsx and .ts files correctly', async () => {
      const result = await detectCircularDependencies(crossFileFixturesPath, {
        pattern: '*.{tsx,ts}',
        ignore: []
      });

      expect(result.summary.filesAnalyzed).toBeGreaterThanOrEqual(4); // All test files
      
      // Should have both clean and circular files
      const hasCleanFiles = result.summary.filesAnalyzed > result.crossFileCycles.length;
      expect(hasCleanFiles).toBe(true);
    });
  });

  describe('Error Handling', () => {
    it('should handle missing import targets gracefully', () => {
      const componentFile = path.join(crossFileFixturesPath, 'component.tsx');
      const parsedFile = parseFile(componentFile);

      // Should not crash when some imports can't be resolved
      expect(parsedFile.imports.length).toBeGreaterThan(0);
      expect(parsedFile.exports.length).toBeGreaterThan(0);
    });
  });
});
</file>

<file path="tests/detector.test.ts">
import { detectCircularDependencies } from '../src/detector';
import * as path from 'path';

describe('Circular Dependency Detector', () => {
  const fixturesPath = path.join(__dirname, 'fixtures');

  describe('Real Circular Dependencies', () => {
    it('should detect circular dependencies in problematic file', async () => {
      const result = await detectCircularDependencies(fixturesPath, {
        pattern: 'circular-example.tsx',
        ignore: []
      });

      expect(result.circularDependencies.length).toBeGreaterThan(0);
      expect(result.summary.circularDependencies).toBeGreaterThan(0);
      
      // Check that it found the specific circular dependencies we created
      const cycles = result.circularDependencies.map(dep => dep.cycle);
      
      // Should find functionA → functionB → functionA cycle
      const hasFunctionCycle = cycles.some(cycle => 
        cycle.includes('functionA') && cycle.includes('functionB')
      );
      expect(hasFunctionCycle).toBe(true);
    });

    it('should provide detailed information about circular dependencies', async () => {
      const result = await detectCircularDependencies(fixturesPath, {
        pattern: 'circular-example.tsx',
        ignore: []
      });

      expect(result.circularDependencies.length).toBeGreaterThan(0);
      
      result.circularDependencies.forEach(dep => {
        expect(dep.file).toContain('circular-example.tsx');
        expect(dep.line).toBeGreaterThan(0);
        expect(dep.hookName).toMatch(/^use(Callback|Memo|Effect)$/);
        expect(dep.cycle).toBeInstanceOf(Array);
        expect(dep.cycle.length).toBeGreaterThanOrEqual(2);
      });
    });
  });

  describe('Clean Code (No Circular Dependencies)', () => {
    it('should not find circular dependencies in clean file', async () => {
      const result = await detectCircularDependencies(fixturesPath, {
        pattern: 'clean-example.tsx',
        ignore: []
      });

      expect(result.circularDependencies).toHaveLength(0);
      expect(result.summary.circularDependencies).toBe(0);
      expect(result.summary.filesAnalyzed).toBe(1);
      expect(result.summary.hooksAnalyzed).toBeGreaterThan(0);
    });
  });

  describe('False Positive Prevention', () => {
    it('should not flag false positives as circular dependencies', async () => {
      const result = await detectCircularDependencies(fixturesPath, {
        pattern: 'false-positive-example.tsx',
        ignore: []
      });

      expect(result.circularDependencies).toHaveLength(0);
      expect(result.summary.circularDependencies).toBe(0);
    });
  });

  describe('Multiple Files', () => {
    it('should analyze multiple files correctly', async () => {
      const result = await detectCircularDependencies(fixturesPath, {
        pattern: '*.tsx',
        ignore: []
      });

      expect(result.summary.filesAnalyzed).toBe(3);
      expect(result.summary.hooksAnalyzed).toBeGreaterThan(0);
      
      // Should only find circular dependencies in the circular-example.tsx file
      const circularFiles = result.circularDependencies.map(dep => 
        path.basename(dep.file)
      );
      
      expect(circularFiles.every(file => file === 'circular-example.tsx')).toBe(true);
    });
  });

  describe('Edge Cases', () => {
    it('should handle empty directories gracefully', async () => {
      const result = await detectCircularDependencies('/tmp/nonexistent', {
        pattern: '*.tsx',
        ignore: []
      });

      expect(result.circularDependencies).toHaveLength(0);
      expect(result.summary.filesAnalyzed).toBe(0);
      expect(result.summary.hooksAnalyzed).toBe(0);
    });

    it('should handle ignore patterns correctly', async () => {
      const result = await detectCircularDependencies(fixturesPath, {
        pattern: '*.tsx',
        ignore: ['**/circular-example.tsx']
      });

      // Should not analyze the ignored file
      const analyzedFiles = result.circularDependencies.map(dep => dep.file);
      expect(analyzedFiles.every(file => !file.includes('circular-example.tsx'))).toBe(true);
      expect(result.summary.circularDependencies).toBe(0);
    });
  });

  describe('Performance', () => {
    it('should complete analysis in reasonable time', async () => {
      const startTime = Date.now();
      
      await detectCircularDependencies(fixturesPath, {
        pattern: '*.tsx',
        ignore: []
      });

      const endTime = Date.now();
      const duration = endTime - startTime;
      
      // Should complete in under 5 seconds for small test files
      expect(duration).toBeLessThan(5000);
    });
  });
});
</file>

<file path="tests/false-positives.test.ts">
import { detectCircularDependencies } from '../src/detector';
import { parseFile } from '../src/parser';
import * as path from 'path';
import * as fs from 'fs';
import * as os from 'os';

describe('False Positive Prevention', () => {
  let tempDir: string;

  beforeEach(() => {
    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'rcd-test-'));
  });

  afterEach(() => {
    fs.rmSync(tempDir, { recursive: true, force: true });
  });

  describe('Variable Name Collisions', () => {
    it('should not flag local variable names that match imported identifiers', async () => {
      const testFile = path.join(tempDir, 'test.tsx');
      fs.writeFileSync(testFile, `
        import React, { useCallback } from 'react';
        
        function Component() {
          const getSenderName = useCallback(async (senderId: string) => {
            const users = await fetchUsers();
            const user = users.find(u => u.id === senderId); // Local 'user' variable
            return user ? user.name : 'Unknown';
          }, []); // No circular dependency here
          
          return <div />;
        }
        
        async function fetchUsers() {
          return [];
        }
      `);

      const result = await detectCircularDependencies(tempDir, {
        pattern: '*.tsx',
        ignore: []
      });

      expect(result.circularDependencies).toHaveLength(0);
    });

    it('should not flag React hooks as circular dependencies', async () => {
      const testFile = path.join(tempDir, 'test.tsx');
      fs.writeFileSync(testFile, `
        import React, { useState, useCallback } from 'react';
        
        function Component() {
          const [user, setUser] = useState(null);
          
          const handleSubmit = useCallback(() => {
            setUser(prev => ({ ...prev, submitted: true }));
          }, []); // setUser is from useState, not circular
          
          return <div />;
        }
      `);

      const result = await detectCircularDependencies(tempDir, {
        pattern: '*.tsx',
        ignore: []
      });

      expect(result.circularDependencies).toHaveLength(0);
    });

    it('should not flag imported functions as circular dependencies', async () => {
      const testFile = path.join(tempDir, 'test.tsx');
      fs.writeFileSync(testFile, `
        import React, { useCallback } from 'react';
        import { getDocs, collection, query } from 'firebase/firestore';
        
        function Component() {
          const fetchData = useCallback(async () => {
            const querySnapshot = await getDocs(query(collection()));
            return querySnapshot.docs;
          }, []); // Firebase functions are imported, not circular
          
          return <div />;
        }
      `);

      const result = await detectCircularDependencies(tempDir, {
        pattern: '*.tsx',
        ignore: []
      });

      expect(result.circularDependencies).toHaveLength(0);
    });
  });

  describe('Property Access Patterns', () => {
    it('should not flag property access as circular dependencies', async () => {
      const testFile = path.join(tempDir, 'test.tsx');
      fs.writeFileSync(testFile, `
        import React, { useCallback } from 'react';
        
        function Component() {
          const user = { id: '1', name: 'John' };
          
          const getName = useCallback(() => {
            return user.name; // Property access, not circular
          }, [user.name]); // Depending on property, not circular
          
          return <div />;
        }
      `);

      const result = await detectCircularDependencies(tempDir, {
        pattern: '*.tsx',
        ignore: []
      });

      expect(result.circularDependencies).toHaveLength(0);
    });
  });

  describe('Constants and Primitives', () => {
    it('should not flag constants as circular dependencies', async () => {
      const testFile = path.join(tempDir, 'test.tsx');
      fs.writeFileSync(testFile, `
        import React, { useMemo } from 'react';
        
        const TIMEOUT = 5000;
        const API_URL = 'https://api.example.com';
        
        function Component() {
          const config = useMemo(() => {
            return {
              timeout: TIMEOUT,
              url: API_URL
            };
          }, [TIMEOUT, API_URL]); // Constants, not circular
          
          return <div />;
        }
      `);

      const result = await detectCircularDependencies(tempDir, {
        pattern: '*.tsx',
        ignore: []
      });

      expect(result.circularDependencies).toHaveLength(0);
    });
  });

  describe('Context and Hook Patterns', () => {
    it('should not flag context values as circular dependencies', async () => {
      const testFile = path.join(tempDir, 'test.tsx');
      fs.writeFileSync(testFile, `
        import React, { useCallback, useContext } from 'react';
        
        const UserContext = React.createContext(null);
        
        function Component() {
          const { user } = useContext(UserContext);
          
          const handleUpdate = useCallback(() => {
            console.log('Updating user:', user);
          }, [user]); // Context value, not circular
          
          return <div />;
        }
      `);

      const result = await detectCircularDependencies(tempDir, {
        pattern: '*.tsx',
        ignore: []
      });

      expect(result.circularDependencies).toHaveLength(0);
    });
  });

  describe('Non-React Files', () => {
    it('should skip files that are not React components', async () => {
      const testFile = path.join(tempDir, 'utils.ts');
      fs.writeFileSync(testFile, `
        // This is a utility file, not a React component
        export function processData(data: any) {
          return data.map((item: any) => ({ ...item, processed: true }));
        }
        
        export const CONSTANTS = {
          API_URL: 'https://api.example.com',
          TIMEOUT: 5000
        };
      `);

      const result = await detectCircularDependencies(tempDir, {
        pattern: '*.ts',
        ignore: []
      });

      // Should analyze 0 files because it's not a React file
      expect(result.summary.filesAnalyzed).toBe(0);
      expect(result.circularDependencies).toHaveLength(0);
    });
  });

  describe('Large Files and Performance', () => {
    it('should skip very large files', async () => {
      const testFile = path.join(tempDir, 'large.tsx');
      // Create a large file that exceeds the 1MB limit
      const largeContent = 'import React from "react";\n' + 'console.log("test");\n'.repeat(50000);
      fs.writeFileSync(testFile, largeContent);

      const result = await detectCircularDependencies(tempDir, {
        pattern: '*.tsx',
        ignore: []
      });

      // Should skip the large file
      expect(result.summary.filesAnalyzed).toBe(0);
    });
  });
});
</file>

<file path="tests/parser.test.ts">
import { parseFile } from '../src/parser';
import * as path from 'path';

describe('Parser', () => {
  const fixturesPath = path.join(__dirname, 'fixtures');

  describe('Hook Extraction', () => {
    it('should extract hooks from React components', () => {
      const filePath = path.join(fixturesPath, 'clean-example.tsx');
      const result = parseFile(filePath);

      expect(result.file).toBe(filePath);
      expect(result.hooks.length).toBeGreaterThan(0);
      
      // Should find useCallback, useMemo, useEffect hooks
      const hookNames = result.hooks.map(hook => hook.name);
      expect(hookNames).toContain('useCallback');
      expect(hookNames).toContain('useMemo');
      expect(hookNames).toContain('useEffect');
    });

    it('should extract hook dependencies correctly', () => {
      const filePath = path.join(fixturesPath, 'circular-example.tsx');
      const result = parseFile(filePath);

      const hooksWithDeps = result.hooks.filter(hook => hook.dependencies.length > 0);
      expect(hooksWithDeps.length).toBeGreaterThan(0);

      // Check that dependencies are extracted as strings
      hooksWithDeps.forEach(hook => {
        expect(hook.dependencies).toBeInstanceOf(Array);
        hook.dependencies.forEach(dep => {
          expect(typeof dep).toBe('string');
          expect(dep.length).toBeGreaterThan(0);
        });
      });
    });

    it('should include line and column information', () => {
      const filePath = path.join(fixturesPath, 'clean-example.tsx');
      const result = parseFile(filePath);

      result.hooks.forEach(hook => {
        expect(hook.line).toBeGreaterThan(0);
        expect(hook.column).toBeGreaterThanOrEqual(0);
        expect(hook.file).toBe(filePath);
      });
    });
  });

  describe('Variable Dependencies', () => {
    it('should extract variable dependencies from function bodies', () => {
      const filePath = path.join(fixturesPath, 'circular-example.tsx');
      const result = parseFile(filePath);

      expect(result.variables).toBeInstanceOf(Map);
      expect(result.variables.size).toBeGreaterThan(0);

      // Check that variable dependencies are tracked
      for (const [varName, deps] of result.variables) {
        expect(typeof varName).toBe('string');
        expect(deps).toBeInstanceOf(Set);
      }
    });
  });

  describe('Supported Hook Types', () => {
    it('should recognize all supported React hooks', () => {
      const filePath = path.join(fixturesPath, 'clean-example.tsx');
      const result = parseFile(filePath);

      const supportedHooks = ['useEffect', 'useLayoutEffect', 'useMemo', 'useCallback', 'useImperativeHandle'];
      const foundHooks = result.hooks.map(hook => hook.name);

      // Should find at least some of the supported hooks
      const hasUseMemo = foundHooks.includes('useMemo');
      const hasUseCallback = foundHooks.includes('useCallback');
      const hasUseEffect = foundHooks.includes('useEffect');

      expect(hasUseMemo || hasUseCallback || hasUseEffect).toBe(true);
    });
  });

  describe('Error Handling', () => {
    it('should handle invalid files gracefully', () => {
      // This should not throw an error for non-existent files
      expect(() => {
        parseFile('/path/to/nonexistent/file.tsx');
      }).toThrow(); // Should throw but not crash the process
    });
  });

  describe('TypeScript Support', () => {
    it('should parse TypeScript React files correctly', () => {
      const filePath = path.join(fixturesPath, 'clean-example.tsx');
      const result = parseFile(filePath);

      // Should successfully parse TypeScript without errors
      expect(result.hooks.length).toBeGreaterThan(0);
      expect(result.file).toBe(filePath);
    });
  });
});
</file>

<file path="debug-test.js">
// Quick debug script to test our parsing
const { parseFile } = require('./dist/parser');
const path = require('path');

const file = path.join(__dirname, 'tests/fixtures/realistic-circular.tsx');
console.log('Parsing file:', file);

try {
  const result = parseFile(file);
  console.log('Parsed result:');
  console.log('Hooks:', result.hooks.length);
  
  result.hooks.forEach((hook, i) => {
    console.log(`\nHook ${i + 1}:`);
    console.log(`  Name: ${hook.name}`);
    console.log(`  Line: ${hook.line}`);
    console.log(`  Dependencies: [${hook.dependencies.join(', ')}]`);
  });
  
  console.log('\nVariables map:');
  for (const [varName, deps] of result.variables.entries()) {
    console.log(`  ${varName}: [${Array.from(deps).join(', ')}]`);
  }
} catch (error) {
  console.error('Error:', error);
}
</file>

<file path="jest.config.js">
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/src', '<rootDir>/tests'],
  testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts'],
  transform: {
    '^.+\\.ts$': 'ts-jest',
  },
  collectCoverageFrom: [
    'src/**/*.ts',
    '!src/**/*.d.ts',
  ],
  coverageDirectory: 'coverage',
  coverageReporters: ['text', 'lcov', 'html'],
};
</file>

<file path="src/cli.ts">
#!/usr/bin/env node

import { Command } from 'commander';
import * as path from 'path';
import * as fs from 'fs';
import chalk from 'chalk';
import { detectCircularDependencies } from './detector';

const program = new Command();

program
  .name('react-circular-deps')
  .description('CLI tool to detect circular dependencies in React hooks dependency arrays')
  .version('1.0.0')
  .argument('<path>', 'Path to React project or file to analyze')
  .option('-p, --pattern <pattern>', 'Glob pattern for files to analyze', '**/*.{js,jsx,ts,tsx}')
  .option('-i, --ignore <patterns...>', 'Patterns to ignore', ['**/node_modules/**', '**/.git/**', '**/dist/**', '**/build/**', '**/.expo/**', '**/.next/**', '**/.nuxt/**', '**/.cache/**'])
  .option('--json', 'Output results as JSON')
  .option('--no-color', 'Disable colored output')
  .action(async (targetPath: string, options: any) => {
    try {
      const absolutePath = path.resolve(targetPath);
      
      if (!fs.existsSync(absolutePath)) {
        console.error(chalk.red(`Error: Path "${absolutePath}" does not exist`));
        process.exit(1);
      }

      if (!options.json) {
        console.log(chalk.blue(`Analyzing React hooks in: ${absolutePath}`));
        console.log(chalk.gray(`Pattern: ${options.pattern}`));
      }
      
      const results = await detectCircularDependencies(absolutePath, {
        pattern: options.pattern,
        ignore: options.ignore,
      });

      if (options.json) {
        console.log(JSON.stringify(results, null, 2));
      } else {
        formatResults(results, options);
      }

      if (results.circularDependencies.length > 0 || results.crossFileCycles.length > 0) {
        process.exit(1);
      }
    } catch (error) {
      console.error(chalk.red('Error:'), error);
      process.exit(1);
    }
  });

function formatResults(results: any, options: any) {
  const { circularDependencies, crossFileCycles, summary } = results;
  
  let hasIssues = false;
  
  // Show hook-level circular dependencies
  if (circularDependencies.length === 0) {
    console.log(chalk.green('✓ No hook-level circular dependencies found!'));
  } else {
    hasIssues = true;
    console.log(chalk.red(`\n✗ Found ${circularDependencies.length} hook-level circular dependencies:\n`));
    
    circularDependencies.forEach((dep: any, index: number) => {
      console.log(chalk.yellow(`${index + 1}. ${path.relative(process.cwd(), dep.file)}:${dep.line}`));
      console.log(chalk.gray(`   Hook: ${dep.hookName}`));
      console.log(chalk.gray(`   Cycle: ${dep.cycle.join(' → ')}`));
      console.log();
    });
  }
  
  // Show cross-file cycles
  if (crossFileCycles.length === 0) {
    console.log(chalk.green('✓ No cross-file circular dependencies found!'));
  } else {
    hasIssues = true;
    console.log(chalk.red(`\n✗ Found ${crossFileCycles.length} cross-file circular dependencies:\n`));
    
    crossFileCycles.forEach((cycle: any, index: number) => {
      console.log(chalk.yellow(`${index + 1}. Cross-file ${cycle.type} cycle:`));
      
      const relativeFiles = cycle.files.map((file: string) => path.relative(process.cwd(), file));
      console.log(chalk.gray(`   Files: ${relativeFiles.join(' → ')}`));
      
      if (cycle.dependencies.length > 0) {
        console.log(chalk.gray(`   Dependencies:`));
        cycle.dependencies.forEach((dep: any) => {
          const fromFile = path.relative(process.cwd(), dep.from);
          const toFile = path.relative(process.cwd(), dep.to);
          console.log(chalk.gray(`     ${fromFile}:${dep.line} → ${toFile} (${dep.importedItems.join(', ')})`));
        });
      }
      console.log();
    });
  }
  
  if (!hasIssues) {
    console.log(chalk.green('\n🎉 No circular dependencies found!'));
  }

  console.log(chalk.blue('\nSummary:'));
  console.log(chalk.gray(`  Files analyzed: ${summary.filesAnalyzed}`));
  console.log(chalk.gray(`  Hooks analyzed: ${summary.hooksAnalyzed}`));
  console.log(chalk.gray(`  Hook-level circular dependencies: ${summary.circularDependencies}`));
  console.log(chalk.gray(`  Cross-file circular dependencies: ${summary.crossFileCycles}`));
  console.log(chalk.gray(`  Total issues: ${summary.circularDependencies + summary.crossFileCycles}`));
}

program.parse();
</file>

<file path="src/detector.ts">
import { glob } from 'glob';
import * as path from 'path';
import * as fs from 'fs';
import { parseFile, HookInfo, ParsedFile } from './parser';
import { buildModuleGraph, detectAdvancedCrossFileCycles, CrossFileCycle } from './module-graph';

export interface CircularDependency {
  file: string;
  line: number;
  hookName: string;
  cycle: string[];
}

export interface DetectionResults {
  circularDependencies: CircularDependency[];
  crossFileCycles: CrossFileCycle[];
  summary: {
    filesAnalyzed: number;
    hooksAnalyzed: number;
    circularDependencies: number;
    crossFileCycles: number;
  };
}

interface DetectorOptions {
  pattern: string;
  ignore: string[];
}

export async function detectCircularDependencies(
  targetPath: string,
  options: DetectorOptions
): Promise<DetectionResults> {
  const files = await findFiles(targetPath, options);
  const parsedFiles: ParsedFile[] = [];
  
  for (const file of files) {
    // Skip files that are definitely not React components
    if (!isLikelyReactFile(file)) {
      continue;
    }
    
    try {
      const parsed = parseFile(file);
      parsedFiles.push(parsed);
    } catch (error) {
      // Only show warnings if not in quiet mode (we'll add a flag for this later)
      if (process.env.NODE_ENV !== 'test') {
        console.warn(`Warning: Could not parse ${file}:`, error);
      }
    }
  }

  const circularDeps = findCircularDependencies(parsedFiles);
  
  // Build module graph and detect cross-file cycles
  const moduleGraph = buildModuleGraph(parsedFiles);
  const allCrossFileCycles = [
    ...moduleGraph.crossFileCycles,
    ...detectAdvancedCrossFileCycles(parsedFiles, moduleGraph)
  ];
  
  const totalHooks = parsedFiles.reduce((sum, file) => sum + file.hooks.length, 0);
  
  return {
    circularDependencies: circularDeps,
    crossFileCycles: allCrossFileCycles,
    summary: {
      filesAnalyzed: parsedFiles.length,
      hooksAnalyzed: totalHooks,
      circularDependencies: circularDeps.length,
      crossFileCycles: allCrossFileCycles.length,
    },
  };
}

function isLikelyReactFile(filePath: string): boolean {
  try {
    // Quick check of file size - skip very large files that are likely bundled/generated
    const stats = fs.statSync(filePath);
    if (stats.size > 1024 * 1024) { // Skip files larger than 1MB
      return false;
    }
    
    // Always include .tsx/.jsx files
    if (/\.(tsx|jsx)$/.test(filePath)) {
      return true;
    }
    
    // For .ts/.js files, check content
    const content = fs.readFileSync(filePath, 'utf-8');
    const firstKB = content.substring(0, 2048); // Check more content
    
    // Look for React-specific patterns
    const hasReactImport = /import.*from\s+['"]react['"]/.test(firstKB) || 
                          /import.*React/.test(firstKB) ||
                          /from\s+['"]react-native['"]/.test(firstKB);
    const hasHooks = /use[A-Z]/.test(firstKB);
    const hasJSX = /<[A-Z]/.test(firstKB);
    const hasReactFunction = /function.*Component|const.*=.*\(\).*=>/.test(firstKB);
    
    return hasReactImport || hasHooks || hasJSX || hasReactFunction;
  } catch (error) {
    return true; // If we can't check, include it
  }
}

async function findFiles(targetPath: string, options: DetectorOptions): Promise<string[]> {
  const pattern = path.join(targetPath, options.pattern);
  const files = await glob(pattern, {
    ignore: options.ignore,
    absolute: true,
  });
  
  // Filter out directories and files that are definitely not React files
  return files.filter(file => {
    try {
      const stats = fs.statSync(file);
      return stats.isFile();
    } catch {
      return false;
    }
  });
}

function findCircularDependencies(parsedFiles: ParsedFile[]): CircularDependency[] {
  const circularDeps: CircularDependency[] = [];
  
  for (const file of parsedFiles) {
    for (const hook of file.hooks) {
      const cycles = detectCyclesInHook(hook, file.variables);
      
      for (const cycle of cycles) {
        circularDeps.push({
          file: file.file,
          line: hook.line,
          hookName: hook.name,
          cycle,
        });
      }
    }
  }
  
  return circularDeps;
}

function detectCyclesInHook(
  hook: HookInfo,
  variables: Map<string, Set<string>>
): string[][] {
  const cycles: string[][] = [];
  const deps = hook.dependencies;
  
  // Only check for actual cycles where functions depend on each other
  // Skip simple variable name matches that don't represent actual dependencies
  for (const dep of deps) {
    const cycle = findRealCircularDependency(dep, variables, new Set(), [dep]);
    if (cycle.length > 2) { // Real cycle must have at least 3 elements
      cycles.push(cycle);
    }
  }
  
  return cycles;
}

function findRealCircularDependency(
  currentVar: string,
  variables: Map<string, Set<string>>,
  visited: Set<string>,
  path: string[]
): string[] {
  if (visited.has(currentVar)) {
    // Found a cycle - return the path from where the cycle starts
    const cycleStart = path.indexOf(currentVar);
    if (cycleStart !== -1) {
      return path.slice(cycleStart).concat([currentVar]);
    }
    return [];
  }
  
  const deps = variables.get(currentVar);
  if (!deps || deps.size === 0) {
    return [];
  }
  
  visited.add(currentVar);
  
  for (const dep of deps) {
    // Skip if this dependency looks like a primitive value or imported function
    if (isPrimitiveOrImported(dep)) {
      continue;
    }
    
    const cycle = findRealCircularDependency(dep, variables, visited, [...path, dep]);
    if (cycle.length > 0) {
      return cycle;
    }
  }
  
  visited.delete(currentVar);
  return [];
}

function isPrimitiveOrImported(varName: string): boolean {
  // Skip common React hooks, imported functions, and primitives
  const commonReactHooks = ['useState', 'useEffect', 'useCallback', 'useMemo', 'useRef', 'useContext', 'useReducer', 'useLayoutEffect'];
  const commonFirebaseFunctions = ['getDocs', 'doc', 'collection', 'query', 'orderBy', 'limit', 'where', 'setDoc', 'updateDoc', 'deleteDoc'];
  const commonUtilFunctions = ['console', 'setTimeout', 'clearTimeout', 'Date', 'Object', 'Array', 'JSON', 'Math', 'Number', 'String', 'Boolean'];
  
  if (commonReactHooks.includes(varName) || 
      commonFirebaseFunctions.includes(varName) || 
      commonUtilFunctions.includes(varName)) {
    return true;
  }
  
  // Skip only obvious primitives and constants, but be more conservative
  if (/^[A-Z_]{2,}$/.test(varName) || // CONSTANTS (at least 2 chars)
      varName.includes('.') || // property access like obj.prop
      /^(true|false|null|undefined)$/.test(varName) || // literal primitives
      /^\d+$/.test(varName)) { // pure numbers
    return true;
  }
  
  // Only skip built-in React hooks, not custom hooks
  if (varName.startsWith('use') && commonReactHooks.includes(varName)) {
    return true;
  }
  
  return false;
}
</file>

<file path="src/parser.ts">
import * as parser from '@babel/parser';
import traverse, { NodePath } from '@babel/traverse';
import * as t from '@babel/types';
import * as fs from 'fs';

export interface HookInfo {
  name: string;
  dependencies: string[];
  line: number;
  column: number;
  file: string;
}

export interface ImportInfo {
  source: string;
  imports: string[];
  isDefaultImport: boolean;
  isNamespaceImport: boolean;
  line: number;
}

export interface ExportInfo {
  name: string;
  isDefault: boolean;
  line: number;
}

export interface ParsedFile {
  file: string;
  hooks: HookInfo[];
  variables: Map<string, Set<string>>;
  imports: ImportInfo[];
  exports: ExportInfo[];
  functions: Set<string>;
  contexts: Set<string>;
}

const REACT_HOOKS = [
  'useEffect',
  'useLayoutEffect',
  'useMemo',
  'useCallback',
  'useImperativeHandle',
];

export function parseFile(filePath: string): ParsedFile {
  const code = fs.readFileSync(filePath, 'utf-8');
  const ast = parser.parse(code, {
    sourceType: 'module',
    plugins: ['jsx', 'typescript'],
  });

  const hooks: HookInfo[] = [];
  const variables = new Map<string, Set<string>>();
  const imports: ImportInfo[] = [];
  const exports: ExportInfo[] = [];
  const functions = new Set<string>();
  const contexts = new Set<string>();

  traverse(ast, {
    ImportDeclaration(path: NodePath<t.ImportDeclaration>) {
      const importInfo = extractImportInfo(path);
      if (importInfo) {
        imports.push(importInfo);
      }
    },

    ExportNamedDeclaration(path: NodePath<t.ExportNamedDeclaration>) {
      const exportInfos = extractNamedExports(path);
      exports.push(...exportInfos);
    },

    ExportDefaultDeclaration(path: NodePath<t.ExportDefaultDeclaration>) {
      const exportInfo = extractDefaultExport(path);
      if (exportInfo) {
        exports.push(exportInfo);
      }
    },

    CallExpression(path: NodePath<t.CallExpression>) {
      const callee = path.node.callee;
      
      if (t.isIdentifier(callee) && REACT_HOOKS.includes(callee.name)) {
        const hookInfo = extractHookInfo(path, callee.name, filePath);
        if (hookInfo) {
          hooks.push(hookInfo);
        }
      }

      // Detect React.createContext calls
      if (t.isMemberExpression(callee) && 
          t.isIdentifier(callee.object) && callee.object.name === 'React' &&
          t.isIdentifier(callee.property) && callee.property.name === 'createContext') {
        const parent = path.parent;
        if (t.isVariableDeclarator(parent) && t.isIdentifier(parent.id)) {
          contexts.add(parent.id.name);
        }
      }
    },
    
    VariableDeclarator(path: NodePath<t.VariableDeclarator>) {
      if (t.isIdentifier(path.node.id)) {
        const varName = path.node.id.name;
        const deps = extractVariableDependencies(path.node.init);
        if (deps.size > 0) {
          variables.set(varName, deps);
        }
      }
    },

    FunctionDeclaration(path: NodePath<t.FunctionDeclaration>) {
      if (path.node.id) {
        functions.add(path.node.id.name);
      }
    },

    ArrowFunctionExpression(path: NodePath<t.ArrowFunctionExpression>) {
      const parent = path.parent;
      if (t.isVariableDeclarator(parent) && t.isIdentifier(parent.id)) {
        functions.add(parent.id.name);
      }
    },
  });

  return { file: filePath, hooks, variables, imports, exports, functions, contexts };
}

function extractHookInfo(
  path: NodePath<t.CallExpression>,
  hookName: string,
  filePath: string
): HookInfo | null {
  const args = path.node.arguments;
  let depsArray: t.ArrayExpression | null = null;

  if (hookName === 'useEffect' || hookName === 'useLayoutEffect') {
    if (args.length >= 2 && t.isArrayExpression(args[1])) {
      depsArray = args[1] as t.ArrayExpression;
    }
  } else if (hookName === 'useMemo' || hookName === 'useCallback') {
    if (args.length >= 2 && t.isArrayExpression(args[1])) {
      depsArray = args[1] as t.ArrayExpression;
    }
  } else if (hookName === 'useImperativeHandle') {
    if (args.length >= 3 && t.isArrayExpression(args[2])) {
      depsArray = args[2] as t.ArrayExpression;
    }
  }

  if (!depsArray) {
    return null;
  }

  const dependencies = depsArray.elements
    .filter((el): el is t.Identifier => t.isIdentifier(el))
    .map(el => el.name);

  const loc = path.node.loc;
  return {
    name: hookName,
    dependencies,
    line: loc?.start.line || 0,
    column: loc?.start.column || 0,
    file: filePath,
  };
}

function extractVariableDependencies(node: t.Node | null | undefined): Set<string> {
  const deps = new Set<string>();
  
  if (!node) return deps;

  try {
    traverse(node, {
      Identifier(path: NodePath<t.Identifier>) {
        if (!path.isReferencedIdentifier()) return;
        
        try {
          const binding = path.scope?.getBinding?.(path.node.name);
          // Only include identifiers that are actually function/variable references
          // Skip built-in objects, imports, and React hooks
          if (!binding || binding.scope === path.scope) return;
          
          const name = path.node.name;
          
          // Skip React hooks and common imports
          if (name.startsWith('use') && name[3] === name[3].toUpperCase()) return;
          if (['console', 'window', 'document', 'process', 'Buffer'].includes(name)) return;
          
          // Only include if it looks like a local variable or function
          if (binding.kind === 'var' || binding.kind === 'let' || binding.kind === 'const' || 
              binding.kind === 'hoisted') {
            deps.add(name);
          }
        } catch (e) {
          // Skip identifiers that cause errors
        }
      },
      noScope: true,
    });
  } catch (e) {
    // Skip nodes that cause errors
  }

  return deps;
}

function extractImportInfo(path: NodePath<t.ImportDeclaration>): ImportInfo | null {
  const source = path.node.source.value;
  const loc = path.node.loc;
  const line = loc?.start.line || 0;
  
  // Skip non-relative imports (external libraries)
  if (!source.startsWith('.') && !source.startsWith('/')) {
    return null;
  }

  const imports: string[] = [];
  let isDefaultImport = false;
  let isNamespaceImport = false;

  path.node.specifiers.forEach(spec => {
    if (t.isImportDefaultSpecifier(spec)) {
      imports.push(spec.local.name);
      isDefaultImport = true;
    } else if (t.isImportNamespaceSpecifier(spec)) {
      imports.push(spec.local.name);
      isNamespaceImport = true;
    } else if (t.isImportSpecifier(spec)) {
      imports.push(spec.local.name);
    }
  });

  return {
    source,
    imports,
    isDefaultImport,
    isNamespaceImport,
    line,
  };
}

function extractNamedExports(path: NodePath<t.ExportNamedDeclaration>): ExportInfo[] {
  const exports: ExportInfo[] = [];
  const loc = path.node.loc;
  const line = loc?.start.line || 0;

  if (path.node.declaration) {
    // export const foo = ...
    // export function foo() { ... }
    if (t.isVariableDeclaration(path.node.declaration)) {
      path.node.declaration.declarations.forEach(decl => {
        if (t.isIdentifier(decl.id)) {
          exports.push({
            name: decl.id.name,
            isDefault: false,
            line,
          });
        }
      });
    } else if (t.isFunctionDeclaration(path.node.declaration) && path.node.declaration.id) {
      exports.push({
        name: path.node.declaration.id.name,
        isDefault: false,
        line,
      });
    }
  } else if (path.node.specifiers) {
    // export { foo, bar }
    path.node.specifiers.forEach(spec => {
      if (t.isExportSpecifier(spec)) {
        exports.push({
          name: spec.exported.type === 'Identifier' ? spec.exported.name : spec.exported.value,
          isDefault: false,
          line,
        });
      }
    });
  }

  return exports;
}

function extractDefaultExport(path: NodePath<t.ExportDefaultDeclaration>): ExportInfo | null {
  const loc = path.node.loc;
  const line = loc?.start.line || 0;

  let name = 'default';

  if (t.isFunctionDeclaration(path.node.declaration) && path.node.declaration.id) {
    name = path.node.declaration.id.name;
  } else if (t.isIdentifier(path.node.declaration)) {
    name = path.node.declaration.name;
  }

  return {
    name,
    isDefault: true,
    line,
  };
}
</file>

<file path="test-files/circular-example.tsx">
import React, { useState, useEffect, useCallback } from 'react';

function CircularExample() {
  const [count, setCount] = useState(0);
  const [data, setData] = useState<any>(null);
  
  const fetchData = useCallback(() => {
    console.log('Fetching data...');
    setData({ value: count });
  }, [count, data]);
  
  const handleIncrement = useCallback(() => {
    setCount(count + 1);
    fetchData();
  }, [count, fetchData]);
  
  useEffect(() => {
    console.log('Effect running', data);
    if (data && data.value < 10) {
      handleIncrement();
    }
  }, [data, handleIncrement]);

  const processedData = React.useMemo(() => {
    return data ? { ...data, processed: true } : null;
  }, [data, processedData]);

  return (
    <div>
      <h1>Count: {count}</h1>
      <button onClick={handleIncrement}>Increment</button>
      <pre>{JSON.stringify(processedData, null, 2)}</pre>
    </div>
  );
}

export default CircularExample;
</file>

<file path="test-files/clean-example.tsx">
import React, { useState, useEffect, useCallback } from 'react';

function CleanExample() {
  const [count, setCount] = useState(0);
  const [data, setData] = useState<any>(null);
  
  const fetchData = useCallback(() => {
    console.log('Fetching data...');
    setData({ value: count });
  }, [count]);
  
  const handleIncrement = useCallback(() => {
    setCount(prev => prev + 1);
  }, []);
  
  useEffect(() => {
    console.log('Effect running', data);
    if (data && data.value < 10) {
      handleIncrement();
    }
  }, [data, handleIncrement]);

  const processedData = React.useMemo(() => {
    return data ? { ...data, processed: true } : null;
  }, [data]);

  return (
    <div>
      <h1>Count: {count}</h1>
      <button onClick={handleIncrement}>Increment</button>
      <pre>{JSON.stringify(processedData, null, 2)}</pre>
    </div>
  );
}

export default CleanExample;
</file>

<file path=".gitignore">
# Dependencies
node_modules/

# Build output
dist/

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Environment variables
.env
.env.local
.env.*.local

# Test coverage
coverage/
.nyc_output/

# Temporary files
*.tmp
*.temp
.cache/

# Package manager files
yarn.lock
pnpm-lock.yaml
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2024 react-circular-deps-detector

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="README.md">
# React Circular Dependencies Detector

A CLI tool to detect circular dependencies in React hooks' dependency arrays. This tool helps identify potential infinite re-render loops caused by circular references in `useEffect`, `useCallback`, `useMemo`, and other React hooks.

## Installation

### Global Installation (Recommended)

```bash
npm install -g react-circular-deps-detector
```

### Local Installation

```bash
npm install --save-dev react-circular-deps-detector
```

## Usage

### Command Line

After global installation, you can use either `react-circular-deps` or the shorter `rcd` command:

```bash
# Analyze a single file
react-circular-deps src/components/MyComponent.tsx

# Analyze an entire project
react-circular-deps ./src

# Using the short alias
rcd ./src

# With custom file pattern
rcd ./src --pattern "**/*.{ts,tsx}"

# Exclude specific patterns (node_modules is excluded by default)
rcd ./src --ignore "**/tests/**" "**/*.test.tsx"

# Output as JSON
rcd ./src --json

# Disable colored output
rcd ./src --no-color
```

### NPM Scripts

If installed locally, add to your `package.json`:

```json
{
  "scripts": {
    "check-circular-deps": "react-circular-deps ./src"
  }
}
```

## What It Detects

The tool analyzes React hooks and identifies circular dependencies like:

```javascript
// Example 1: Circular dependency between callbacks
const [data, setData] = useState(null);

const fetchData = useCallback(() => {
  processData();
}, [data, processData]); // 🔴 Circular: fetchData → processData → fetchData

const processData = useCallback(() => {
  setData(fetchData());
}, [fetchData]);

// Example 2: Self-referential dependency
const memoizedValue = useMemo(() => {
  return computeValue(memoizedValue); // 🔴 Self-reference
}, [memoizedValue]);

// Example 3: Multiple hook circular dependency
useEffect(() => {
  handleChange();
}, [value, handleChange]); // 🔴 If handleChange depends on value
```

## Options

- `--pattern, -p <pattern>`: Glob pattern for files to analyze (default: `**/*.{js,jsx,ts,tsx}`)
- `--ignore, -i <patterns...>`: Patterns to ignore (default: `node_modules`, `.git`, `dist`, `build`, etc.)
- `--json`: Output results as JSON for CI/CD integration
- `--no-color`: Disable colored output
- `--help`: Display help information
- `--version`: Display version

## Exit Codes

- `0`: No circular dependencies found
- `1`: Circular dependencies detected or error occurred

## Default Ignored Patterns

The following patterns are ignored by default:
- `**/node_modules/**`
- `**/.git/**`
- `**/dist/**`
- `**/build/**`
- `**/.expo/**`
- `**/.next/**`
- `**/.nuxt/**`
- `**/.cache/**`

## Output Example

```
Analyzing React hooks in: /path/to/project
Pattern: **/*.{js,jsx,ts,tsx}

✗ Found 2 circular dependencies:

1. src/components/UserProfile.tsx:45
   Hook: useCallback
   Cycle: updateUser → userData → fetchUser

2. src/hooks/useDataSync.ts:78
   Hook: useEffect
   Cycle: syncData → localData → syncData

Summary:
  Files analyzed: 23
  Hooks analyzed: 67
  Circular dependencies: 2
```

## Integration with CI/CD

Use the JSON output for easy integration with CI/CD pipelines:

```bash
# In your CI script
rcd ./src --json > circular-deps-report.json

# The tool exits with code 1 if circular dependencies are found
if [ $? -eq 1 ]; then
  echo "Circular dependencies detected!"
  exit 1
fi
```

## Development

### Running Tests

```bash
# Run tests
npm test

# Run tests with coverage
npm run test:coverage

# Run tests in watch mode
npm run test:watch
```

### Building

```bash
# Build the project
npm run build

# Build in watch mode
npm run dev
```

## License

MIT
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
</file>

<file path="package.json">
{
  "name": "react-circular-deps-detector",
  "version": "1.0.0",
  "description": "CLI tool to detect circular dependencies in React hooks dependency arrays",
  "main": "dist/cli.js",
  "bin": {
    "react-circular-deps": "./dist/cli.js",
    "rcd": "./dist/cli.js"
  },
  "preferGlobal": true,
  "scripts": {
    "build": "tsc",
    "dev": "tsc --watch",
    "prepublishOnly": "npm run build",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage"
  },
  "keywords": [
    "react",
    "circular-dependencies",
    "hooks",
    "useEffect",
    "useCallback",
    "useMemo",
    "linter",
    "cli"
  ],
  "author": "",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/samsmithyeah/react-circular-deps-detector.git"
  },
  "engines": {
    "node": ">=14.0.0"
  },
  "files": [
    "dist",
    "README.md",
    "LICENSE"
  ],
  "devDependencies": {
    "@babel/parser": "^7.27.5",
    "@babel/traverse": "^7.27.4",
    "@babel/types": "^7.27.6",
    "@types/babel__traverse": "^7.20.7",
    "@types/jest": "^30.0.0",
    "@types/node": "^24.0.3",
    "jest": "^30.0.1",
    "ts-jest": "^29.4.0",
    "typescript": "^5.8.3"
  },
  "dependencies": {
    "chalk": "^4.1.2",
    "commander": "^14.0.0",
    "glob": "^11.0.3"
  }
}
</file>

</files>
